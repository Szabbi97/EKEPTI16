GOF - Design Patterns
GOF = Gang Of Four


Object Oriented Principles

- Encapsulation: Data Structure + Methods -> Class
- Inheritance: Inheritance should be kept safe. The child class inherits the implementation of the parent class
- Polymorphism: An object has more types and we can use it as on object of all these types

Object has
- Innerstate
- Behaviour
- Type or Interface

Class has problems
- Interface
  - interface
- Implementation
- Abstract class
  - interface
  - incomplete implementation

class Dog:IMakingNoise
{
  bool happy; //It's a field or attribute
  public void setHappy(bool happy)
  {
    this.happy = happy;
  }
  public string Bark()
  {
    if(happy)
      return "gav-gav";
    else
      return "brrrr";
  }
  public string Noise()
  {
    return Bark();
  }
}

MAIN
{
  Dog d1 = new WatcDog();
  Console.WriteLine(d1.Bark());
  d1.setHappy(false);
  Object o1 = d1; // This is allowed because the Object is parent of Dog;
  Console.WriteLine(d1.Bark());
}

Interface IMakingNoise
{
  string Noise();
}


Innerstate - The actual values of the fields
Behaviour - The behaviour changes over the time, depends the innerstate. If we change the innerstate the behaviour also changes.

Question: What is the difference between implementation and behaviour?
Anwser: Implementation and behaviour are both something related to the source code. The implementation is the source code, behaviour is the running source code.
Both are about the source code.

Type -

UML: Unified Modelling Language
-Class diagrams

Rectangle = class -> Object <- Dog
         WatchDog ->        <- Cat
                            <- <<INTERFACE>> IMakingNoise
Hierarchy
Each object gets, each type goes up on the hierarchy of inheritance.

The interface ... the signatures of public classes.

An abstract method has no body.
An abstract class has interface and some implementation. The implementation might be incomlete.

We can use an interface as a type.

Design patterns

Singleton - Ensure a class only has one instance and provide a global point of access to it.

class MySingleton
{
  private MySingleton(){}

  private static MySingleton instance = new MySingleton();

  public static MySingleton GetInstance() //Global access point
  {
    return instance;
  }
}

class Dog
{
  string name;
  string color;
  int age;
  public string getName()
  {
    return color;
  }
  public string getColor()
  {
    return color;
  }
  public int getAge()
  {
    return age;
  }
}

MAIN
{
  MySingleton S1 = MySingleton.GetInstance
}


Object Oriented Design Principles

1.: GOF One
	- Program to an interface not an implementation.
2.: GOF Two
	- Favour object composition over class inheritance.

	
Program to an implementation means that you use your knowledge how other classes are implemented to implement a new class.
If you do so than your code will be short and fast, which seems to be fine.

Our main principle is the source code is always changing, because there are new feature requests, sometimes we find a bug and we eleminate the bug, sometimes we just make the source code claner (refactor the program).
This is a common fenomena.

The problem is with to program to an implementation that the classes are tightly coupled. 

- Thightly coupled
- Loosly coupled
- Layers = Tier

Tightly coupled: If you change the source code of a class, most probably you have to change the source code of other classes which are tightly coupled to this one. 

The most important dependency is implementation dependency. Implementation dependency means that if i change the class I also have to change the dependent classes.

Dependence on specific implementation. Dependence on software or hardware. 

Read book from page 23 - 25. Chapter: Designing for change.

Program to an interface.

Program to an interface is to write your class that you're only knowing the implementation of other classes.
If you program to an interface you can be sure that you shouldn't change other classes, until you do not hurt the contract of the interface.

Contract of a method consists of precondition and the post condition of a method.
The precondition describes for what kind of parameters and inner state the method should work properly.
The postcondition speaks about the return value of the method. and the inner state.


using System.Diagnostics;
class BankAccount
{
	double ammount;
	/// <summary>
    /// Get money.
    /// </summary>
    /// <param name="ammount">The ammount wich is drawn from the account. This ammount shouldn't be greater than your actual money.</param>
	public bool Invriant()
	{
		return ammount >= 0;
	}
	public bool DrawMoney(double ammount)
	{
		Debug.Assert(this.ammount >= ammount); //PRE
		this.ammount -= ammount;
		Debug.Assert(this.ammount >=0); //POST
	}
	public
}

The contract of an interface consist of a method or class invariant.

A class invariant is a property which is true before and after each method call.